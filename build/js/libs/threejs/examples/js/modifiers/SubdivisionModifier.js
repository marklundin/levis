THREE.SubdivisionModifier=function(e){this.subdivisions=void 0===e?1:e;this.useOldVertexColors=!1;this.supportUVs=!0;this.debug=!1};THREE.SubdivisionModifier.prototype.modify=function(e){var t=this.subdivisions;for(;t-->0;)this.smooth(e)};THREE.GeometryUtils.orderedKey=function(e,t){return Math.min(e,t)+"_"+Math.max(e,t)};THREE.GeometryUtils.computeEdgeFaces=function(e){function t(e,t){if(void 0===a[e])a[e]=[];a[e].push(t)}var i,r,n,o,a={};var s=THREE.GeometryUtils.orderedKey;for(i=0,r=e.faces.length;r>i;i++){n=e.faces[i];if(n instanceof THREE.Face3){o=s(n.a,n.b);t(o,i);o=s(n.b,n.c);t(o,i);o=s(n.c,n.a);t(o,i)}else if(n instanceof THREE.Face4){o=s(n.a,n.b);t(o,i);o=s(n.b,n.c);t(o,i);o=s(n.c,n.d);t(o,i);o=s(n.d,n.a);t(o,i)}}return a};THREE.SubdivisionModifier.prototype.smooth=function(e){function t(){if(d.debug&&console&&console.assert)console.assert.apply(console,arguments)}function i(){if(d.debug)console.log.apply(console,arguments)}function r(){if(console)console.log.apply(console,arguments)}function n(e,t,r,n,a,s,l){var h=new THREE.Face4(e,t,r,n,null,a.color,a.materialIndex);if(d.useOldVertexColors){h.vertexColors=[];var f,p,m;for(var v=0;4>v;v++){m=s[v];f=new THREE.Color,f.setRGB(0,0,0);for(var g=0;g<m.length;g++){p=a.vertexColors[m[g]-1];f.r+=p.r;f.g+=p.g;f.b+=p.b}f.r/=m.length;f.g/=m.length;f.b/=m.length;h.vertexColors[v]=f}}c.push(h);if(d.supportUVs){var E=[o(e,""),o(t,l),o(r,l),o(n,l)];if(!E[0])i("a :( ",e+":"+l);else if(!E[1])i("b :( ",t+":"+l);else if(!E[2])i("c :( ",r+":"+l);else if(!E[3])i("d :( ",n+":"+l);else u.push(E)}}function o(e,t){var n=e+":"+t;var o=x[n];if(!o){if(e>=g&&e<g+v.length)i("face pt");else i("edge pt");r("warning, UV not found for",n);return null}return o}function a(e,t,i){var n=e+":"+t;if(!(n in x))x[n]=i;else r("dup vertexNo",e,"oldFaceNo",t,"value",i,"key",n,x[n])}function s(e,t){if(void 0===W[e])W[e]=[];W[e].push(t)}function l(e,t,i){if(void 0===G[e])G[e]={};G[e][t]=i}var h=[],c=[],u=[];var d=this;var f=THREE.GeometryUtils.orderedKey;var p=THREE.GeometryUtils.computeEdgeFaces;var m=e.vertices;var v=e.faces;var g=m.length;var E=m.concat();var y=[],_={};var T={},b=[];var x={};var w,R,H,S,M;var C=e.faceVertexUvs[0];var A,D="abcd";i("originalFaces, uvs, originalVerticesLength",v.length,C.length,g);if(d.supportUVs)for(w=0,R=C.length;R>w;w++)for(H=0,S=C[w].length;S>H;H++){A=v[w][D.charAt(H)];a(A,w,C[w][H])}if(0==C.length)d.supportUVs=!1;var P=0;for(var L in x)P++;if(!P){d.supportUVs=!1;i("no uvs")}var k;for(w=0,R=v.length;R>w;w++){M=v[w];y.push(M.centroid);E.push(M.centroid);if(d.supportUVs){k=new THREE.Vector2;if(M instanceof THREE.Face3){k.x=o(M.a,w).x+o(M.b,w).x+o(M.c,w).x;k.y=o(M.a,w).y+o(M.b,w).y+o(M.c,w).y;k.x/=3;k.y/=3}else if(M instanceof THREE.Face4){k.x=o(M.a,w).x+o(M.b,w).x+o(M.c,w).x+o(M.d,w).x;k.y=o(M.a,w).y+o(M.b,w).y+o(M.c,w).y+o(M.d,w).y;k.x/=4;k.y/=4}a(g+w,"",k)}else;}var N=p(e);var O,I,F,z;var V=0;var B,U,j;var W={};var G={};for(w in N){O=N[w];B=w.split("_");U=B[0];j=B[1];s(U,[U,j]);s(j,[U,j]);for(H=0,S=O.length;S>H;H++){M=O[H];l(U,M,w);l(j,M,w)}if(O.length<2){T[w]=!0;b[U]=!0;b[j]=!0}}for(w in N){O=N[w];I=O[0];F=O[1];B=w.split("_");U=B[0];j=B[1];z=new THREE.Vector3;t(O.length>0,"an edge without faces?!");if(1==O.length){z.add(m[U]);z.add(m[j]);z.multiplyScalar(.5);b[E.length]=!0}else{z.add(y[I]);z.add(y[F]);z.add(m[U]);z.add(m[j]);z.multiplyScalar(.25)}_[w]=g+v.length+V;E.push(z);V++;if(d.supportUVs){k=new THREE.Vector2;k.x=o(U,I).x+o(j,I).x;k.y=o(U,I).y+o(j,I).y;k.x/=2;k.y/=2;a(_[w],I,k);if(O.length>=2){t(2==O.length,"did we plan for more than 2 edges?");k=new THREE.Vector2;k.x=o(U,F).x+o(j,F).x;k.y=o(U,F).y+o(j,F).y;k.x/=2;k.y/=2;a(_[w],F,k)}}else;}i("-- Step 2 done");var X,Y;var q,K,Z,Q,$;var J=["123","12","2","23"];var et=["123","23","3","31"];var tt=["123","31","1","12"];var it=["1234","12","2","23"];var rt=["1234","23","3","34"];var nt=["1234","34","4","41"];var ot=["1234","41","1","12"];for(w=0,R=y.length;R>w;w++){X=y[w];M=v[w];Y=g+w;if(M instanceof THREE.Face3){q=f(M.a,M.b);K=f(M.b,M.c);$=f(M.c,M.a);n(Y,_[q],M.b,_[K],M,J,w);n(Y,_[K],M.c,_[$],M,et,w);n(Y,_[$],M.a,_[q],M,tt,w)}else if(M instanceof THREE.Face4){q=f(M.a,M.b);K=f(M.b,M.c);Z=f(M.c,M.d);Q=f(M.d,M.a);n(Y,_[q],M.b,_[K],M,it,w);n(Y,_[K],M.c,_[Z],M,rt,w);n(Y,_[Z],M.d,_[Q],M,nt,w);n(Y,_[Q],M.a,_[q],M,ot,w)}else i("face should be a face!",M)}h=E;var at=new THREE.Vector3;var st=new THREE.Vector3;var lt;for(w=0,R=m.length;R>w;w++)if(void 0!==W[w]){at.set(0,0,0);st.set(0,0,0);var ht=new THREE.Vector3(0,0,0);var ct=0;for(H in G[w]){at.add(y[H]);ct++}var ut=0;lt=W[w].length;var dt=ct!=lt;for(H=0;lt>H;H++)if(T[f(W[w][H][0],W[w][H][1])])ut++;at.divideScalar(ct);var ft=0;if(dt){var pt;for(H=0;lt>H;H++){O=W[w][H];pt=1==N[f(O[0],O[1])].length;if(pt){var mt=m[O[0]].clone().add(m[O[1]]).divideScalar(2);st.add(mt);ft++}}st.divideScalar(4);t(2==ft,"should have only 2 boundary edges")}else{for(H=0;lt>H;H++){O=W[w][H];var mt=m[O[0]].clone().add(m[O[1]]).divideScalar(2);st.add(mt)}st.divideScalar(lt)}ht.add(m[w]);if(dt){ht.divideScalar(2);ht.add(st)}else{ht.multiplyScalar(lt-3);ht.add(at);ht.add(st.multiplyScalar(2));ht.divideScalar(lt)}h[w]=ht}else;var vt=e;vt.vertices=h;vt.faces=c;vt.faceVertexUvs[0]=u;delete vt.__tmpVertices;vt.computeCentroids();vt.computeFaceNormals();vt.computeVertexNormals()};