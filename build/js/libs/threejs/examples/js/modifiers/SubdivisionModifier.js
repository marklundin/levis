THREE.SubdivisionModifier=function(e){this.subdivisions=void 0===e?1:e,this.useOldVertexColors=!1,this.supportUVs=!0,this.debug=!1},THREE.SubdivisionModifier.prototype.modify=function(e){for(var t=this.subdivisions;t-->0;)this.smooth(e)},THREE.GeometryUtils.orderedKey=function(e,t){return Math.min(e,t)+"_"+Math.max(e,t)},THREE.GeometryUtils.computeEdgeFaces=function(e){function t(e,t){void 0===a[e]&&(a[e]=[]),a[e].push(t)}var i,r,n,o,a={},s=THREE.GeometryUtils.orderedKey;for(i=0,r=e.faces.length;r>i;i++)n=e.faces[i],n instanceof THREE.Face3?(o=s(n.a,n.b),t(o,i),o=s(n.b,n.c),t(o,i),o=s(n.c,n.a),t(o,i)):n instanceof THREE.Face4&&(o=s(n.a,n.b),t(o,i),o=s(n.b,n.c),t(o,i),o=s(n.c,n.d),t(o,i),o=s(n.d,n.a),t(o,i));return a},THREE.SubdivisionModifier.prototype.smooth=function(e){function t(){E.debug&&console&&console.assert&&console.assert.apply(console,arguments)}function i(){E.debug&&console.log.apply(console,arguments)}function r(){console&&console.log.apply(console,arguments)}function n(e,t,r,n,a,s,l){var h=new THREE.Face4(e,t,r,n,null,a.color,a.materialIndex);if(E.useOldVertexColors){h.vertexColors=[];for(var c,u,d,p=0;4>p;p++){d=s[p],c=new THREE.Color,c.setRGB(0,0,0);for(var f=0;f<d.length;f++)u=a.vertexColors[d[f]-1],c.r+=u.r,c.g+=u.g,c.b+=u.b;c.r/=d.length,c.g/=d.length,c.b/=d.length,h.vertexColors[p]=c}}if(g.push(h),E.supportUVs){var m=[o(e,""),o(t,l),o(r,l),o(n,l)];m[0]?m[1]?m[2]?m[3]?v.push(m):i("d :( ",n+":"+l):i("c :( ",r+":"+l):i("b :( ",t+":"+l):i("a :( ",e+":"+l)}}function o(e,t){var n=e+":"+t,o=C[n];return o?o:(e>=x&&e<x+b.length?i("face pt"):i("edge pt"),r("warning, UV not found for",n),null)}function a(e,t,i){var n=e+":"+t;n in C?r("dup vertexNo",e,"oldFaceNo",t,"value",i,"key",n,C[n]):C[n]=i}function s(e,t){void 0===W[e]&&(W[e]=[]),W[e].push(t)}function l(e,t,i){void 0===G[e]&&(G[e]={}),G[e][t]=i}var h,c,u,d,p,f,m=[],g=[],v=[],E=this,y=THREE.GeometryUtils.orderedKey,_=THREE.GeometryUtils.computeEdgeFaces,T=e.vertices,b=e.faces,x=T.length,w=T.concat(),R=[],H={},S={},M=[],C={},A=e.faceVertexUvs[0],D="abcd";if(i("originalFaces, uvs, originalVerticesLength",b.length,A.length,x),E.supportUVs)for(h=0,c=A.length;c>h;h++)for(u=0,d=A[h].length;d>u;u++)f=b[h][D.charAt(u)],a(f,h,A[h][u]);0==A.length&&(E.supportUVs=!1);var P=0;for(var L in C)P++;P||(E.supportUVs=!1,i("no uvs"));var k;for(h=0,c=b.length;c>h;h++)p=b[h],R.push(p.centroid),w.push(p.centroid),E.supportUVs&&(k=new THREE.Vector2,p instanceof THREE.Face3?(k.x=o(p.a,h).x+o(p.b,h).x+o(p.c,h).x,k.y=o(p.a,h).y+o(p.b,h).y+o(p.c,h).y,k.x/=3,k.y/=3):p instanceof THREE.Face4&&(k.x=o(p.a,h).x+o(p.b,h).x+o(p.c,h).x+o(p.d,h).x,k.y=o(p.a,h).y+o(p.b,h).y+o(p.c,h).y+o(p.d,h).y,k.x/=4,k.y/=4),a(x+h,"",k));var N,I,O,F,z,V,B,U=_(e),j=0,W={},G={};for(h in U){for(N=U[h],z=h.split("_"),V=z[0],B=z[1],s(V,[V,B]),s(B,[V,B]),u=0,d=N.length;d>u;u++)p=N[u],l(V,p,h),l(B,p,h);N.length<2&&(S[h]=!0,M[V]=!0,M[B]=!0)}for(h in U)N=U[h],I=N[0],O=N[1],z=h.split("_"),V=z[0],B=z[1],F=new THREE.Vector3,t(N.length>0,"an edge without faces?!"),1==N.length?(F.add(T[V]),F.add(T[B]),F.multiplyScalar(.5),M[w.length]=!0):(F.add(R[I]),F.add(R[O]),F.add(T[V]),F.add(T[B]),F.multiplyScalar(.25)),H[h]=x+b.length+j,w.push(F),j++,E.supportUVs&&(k=new THREE.Vector2,k.x=o(V,I).x+o(B,I).x,k.y=o(V,I).y+o(B,I).y,k.x/=2,k.y/=2,a(H[h],I,k),N.length>=2&&(t(2==N.length,"did we plan for more than 2 edges?"),k=new THREE.Vector2,k.x=o(V,O).x+o(B,O).x,k.y=o(V,O).y+o(B,O).y,k.x/=2,k.y/=2,a(H[h],O,k)));i("-- Step 2 done");var X,Y,q,K,Z,Q,$,J=["123","12","2","23"],et=["123","23","3","31"],tt=["123","31","1","12"],it=["1234","12","2","23"],rt=["1234","23","3","34"],nt=["1234","34","4","41"],ot=["1234","41","1","12"];for(h=0,c=R.length;c>h;h++)X=R[h],p=b[h],Y=x+h,p instanceof THREE.Face3?(q=y(p.a,p.b),K=y(p.b,p.c),$=y(p.c,p.a),n(Y,H[q],p.b,H[K],p,J,h),n(Y,H[K],p.c,H[$],p,et,h),n(Y,H[$],p.a,H[q],p,tt,h)):p instanceof THREE.Face4?(q=y(p.a,p.b),K=y(p.b,p.c),Z=y(p.c,p.d),Q=y(p.d,p.a),n(Y,H[q],p.b,H[K],p,it,h),n(Y,H[K],p.c,H[Z],p,rt,h),n(Y,H[Z],p.d,H[Q],p,nt,h),n(Y,H[Q],p.a,H[q],p,ot,h)):i("face should be a face!",p);m=w;var at,st=new THREE.Vector3,lt=new THREE.Vector3;for(h=0,c=T.length;c>h;h++)if(void 0!==W[h]){st.set(0,0,0),lt.set(0,0,0);var ht=new THREE.Vector3(0,0,0),ct=0;for(u in G[h])st.add(R[u]),ct++;var ut=0;at=W[h].length;var dt=ct!=at;for(u=0;at>u;u++)S[y(W[h][u][0],W[h][u][1])]&&ut++;st.divideScalar(ct);var pt=0;if(dt){var ft;for(u=0;at>u;u++)if(N=W[h][u],ft=1==U[y(N[0],N[1])].length){var mt=T[N[0]].clone().add(T[N[1]]).divideScalar(2);lt.add(mt),pt++}lt.divideScalar(4),t(2==pt,"should have only 2 boundary edges")}else{for(u=0;at>u;u++){N=W[h][u];var mt=T[N[0]].clone().add(T[N[1]]).divideScalar(2);lt.add(mt)}lt.divideScalar(at)}ht.add(T[h]),dt?(ht.divideScalar(2),ht.add(lt)):(ht.multiplyScalar(at-3),ht.add(st),ht.add(lt.multiplyScalar(2)),ht.divideScalar(at)),m[h]=ht}var gt=e;gt.vertices=m,gt.faces=g,gt.faceVertexUvs[0]=v,delete gt.__tmpVertices,gt.computeCentroids(),gt.computeFaceNormals(),gt.computeVertexNormals()};